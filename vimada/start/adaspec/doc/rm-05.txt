*rm-05.txt*

                               5   Statements *ada-statements*


1   A statement defines an action to be performed upon its execution.

2/3 This clause describes the general rules applicable to all statements. Some
statements are discussed in later clauses: Procedure_call_statements and
return statements are described in 6, "Subprograms". Entry_call_statements,
requeue_statements, delay_statements, accept_statements, select_statements,
and abort_statements are described in 9, "Tasks and Synchronization". Raise_-
statements are described in 11, "Exceptions", and code_statements in 13. The
remaining forms of statements are presented in this clause.


5.1 Simple and Compound Statements - Sequences of Statements *ada-statements-simple*


1   A statement is either simple or compound. A simple_statement encloses no
other statement. A compound_statement can enclose simple_statements and other
compound_statements.


                                   Syntax

2/3     sequence_of_statements ::= statement {statement} {label}

3       statement ::=
           {label} simple_statement | {label} compound_statement

4/2     simple_statement ::= null_statement
           | assignment_statement            | exit_statement
           | goto_statement                  | procedure_call_statement
           | simple_return_statement         | entry_call_statement
           | requeue_statement               | delay_statement
           | abort_statement                 | raise_statement
           | code_statement

5/2     compound_statement ::=
             if_statement                    | case_statement
           | loop_statement                  | block_statement
           | extended_return_statement
           | accept_statement                | select_statement

6       null_statement ::= null;

7       label ::= <<label_statement_identifier>>

8       statement_identifier ::= direct_name

9       The direct_name of a statement_identifier shall be an identifier (not
        an operator_symbol).


                            Name Resolution Rules

10  The direct_name of a statement_identifier shall resolve to denote its
corresponding implicit declaration (see below).


                               Legality Rules

11  Distinct identifiers shall be used for all statement_identifiers that
appear in the same body, including inner block_statements but excluding inner
program units.


                              Static Semantics

12  For each statement_identifier, there is an implicit declaration (with the
specified identifier) at the end of the declarative_part of the innermost
block_statement or body that encloses the statement_identifier. The implicit
declarations occur in the same order as the statement_identifiers occur in the
source text. If a usage name denotes such an implicit declaration, the entity
it denotes is the label, loop_statement, or block_statement with the given
statement_identifier.

12.1/3 If one or more labels end a sequence_of_statements, an implicit
null_statement follows the labels before any following constructs.


                              Dynamic Semantics

13  The execution of a null_statement has no effect.

14/2 A transfer of control is the run-time action of an exit_statement, return
statement, goto_statement, or requeue_statement, selection of a
terminate_alternative, raising of an exception, or an abort, which causes the
next action performed to be one other than what would normally be expected
from the other rules of the language. As explained in 7.6.1, a transfer of
control can cause the execution of constructs to be completed and then left,
which may trigger finalization.

15  The execution of a sequence_of_statements consists of the execution of the
individual statements in succession until the sequence_ is completed.

        NOTES

16      1  A statement_identifier that appears immediately within the
        declarative region of a named loop_statement or an accept_statement is
        nevertheless implicitly declared immediately within the declarative
        region of the innermost enclosing body or block_statement; in other
        words, the expanded name for a named statement is not affected by
        whether the statement occurs inside or outside a named loop or an
        accept_statement - only nesting within block_statements is relevant to
        the form of its expanded name.


                                  Examples

17  Examples of labeled statements:

18      <<Here>> <<Ici>> <<Aqui>> <<Hier>> null;

19      <<After>> X := 1;


5.2 Assignment Statements *ada-statements-assignment*


1   An assignment_statement replaces the current value of a variable with the
result of evaluating an expression.


                                   Syntax

2       assignment_statement ::=
           variable_name := expression;

3   The execution of an assignment_statement includes the evaluation of the
expression and the assignment of the value of the expression into the target.
An assignment operation (as opposed to an assignment_statement) is performed
in other contexts as well, including object initialization and by-copy
parameter passing. The target of an assignment operation is the view of the
object to which a value is being assigned; the target of an assignment_-
statement is the variable denoted by the variable_name.


                            Name Resolution Rules

4/2 The variable_name of an assignment_statement is expected to be of any
type. The expected type for the expression is the type of the target.


                               Legality Rules

5/2 The target denoted by the variable_name shall be a variable of a
nonlimited type.

6   If the target is of a tagged class-wide type T'Class, then the
expression shall either be dynamically tagged, or of type T and
tag-indeterminate (see 3.9.2).


                              Dynamic Semantics

7   For the execution of an assignment_statement, the variable_name and the
expression are first evaluated in an arbitrary order.

8   When the type of the target is class-wide:

9     * If the expression is tag-indeterminate (see 3.9.2), then the
        controlling tag value for the expression is the tag of the target;

10    * Otherwise (the expression is dynamically tagged), a check is made that
        the tag of the value of the expression is the same as that of the
        target; if this check fails, Constraint_Error is raised.

11  The value of the expression is converted to the subtype of the target. The
conversion might raise an exception (see 4.6).

12  In cases involving controlled types, the target is finalized, and an
anonymous object might be used as an intermediate in the assignment, as
described in 7.6.1, "Completion and Finalization". In any case, the converted
value of the expression is then assigned to the target, which consists of the
following two steps:

13    * The value of the target becomes the converted value.

14/3   * If any part of the target is controlled, its value is adjusted as
        explained in subclause 7.6.

        NOTES

15      2  The tag of an object never changes; in particular, an
        assignment_statement does not change the tag of the target.

16/2    This paragraph was deleted.


                                  Examples

17  Examples of assignment statements:

18      Value := Max_Value - 1;
        Shade := Blue;

19      Next_Frame(F)(M, N) := 2.5;        --  see 4.1.1
        U := Dot_Product(V, W);            --  see 6.3

20/4    Writer := (Status => Open, Unit => Printer, Line_Count => 60);  -- see 3.8.1
        Next.all := (72074, null, Head);   --  see 3.10.1

21  Examples involving scalar subtype conversions:

22      I, J : Integer range 1 .. 10 := 5;
        K    : Integer range 1 .. 20 := 15;
         ...

23      I := J;  --  identical ranges
        K := J;  --  compatible ranges
        J := K;  --  will raise Constraint_Error if K > 10

24  Examples involving array subtype conversions:

25      A : String(1 .. 31);
        B : String(3 .. 33);
         ...

26      A := B;  --  same number of components

27      A(1 .. 9)  := "tar sauce";
        A(4 .. 12) := A(1 .. 9);  --  A(1 .. 12) = "tartar sauce"

        NOTES

28      3  Notes on the examples: Assignment_statements are allowed even in
        the case of overlapping slices of the same array, because the
        variable_name and expression are both evaluated before copying the value into
        the variable. In the above example, an implementation yielding A(1 ..
        12) = "tartartartar" would be incorrect.


5.3 If Statements *ada-statements-if*


1   An if_statement selects for execution at most one of the enclosed
sequences_of_statements, depending on the (truth) value of one or more
corresponding conditions.


                                   Syntax

2       if_statement ::=
            if condition then
              sequence_of_statements
           {elsif condition then
              sequence_of_statements}
           [else
              sequence_of_statements]
            end if;

Paragraphs 3 and 4 were deleted.


                              Dynamic Semantics

5/3 For the execution of an if_statement, the condition specified after if,
and any conditions specified after elsif, are evaluated in succession
(treating a final else as elsif True then), until one evaluates to True or all
conditions are evaluated and yield False. If a condition evaluates to True,
then the corresponding sequence_of_statements is executed; otherwise, none of
them is executed.


                                  Examples

6   Examples of if statements:

7       if Month = December and Day = 31 then
           Month := January;
           Day   := 1;
           Year  := Year + 1;
        end if;

8       if Line_Too_Short then
           raise Layout_Error;
        elsif Line_Full then
           New_Line;
           Put(Item);
        else
           Put(Item);
        end if;

9       if My_Car.Owner.Vehicle /= My_Car then            --  see 3.10.1
           Report ("Incorrect data");
        end if;


5.4 Case Statements *ada-statements-case*


1   A case_statement selects for execution one of a number of alternative
sequences_of_statements; the chosen alternative is defined by the value of an
expression.


                                   Syntax

2/3     case_statement ::=
           case selecting_expression is
               case_statement_alternative
              {case_statement_alternative}
           end case;

3       case_statement_alternative ::=
           when discrete_choice_list =>
              sequence_of_statements


                            Name Resolution Rules

4/3 The selecting_expression is expected to be of any discrete type. The
expected type for each discrete_choice is the type of the
selecting_expression.


                               Legality Rules

5/3 The choice_expressions, subtype_indications, and ranges given as
discrete_choices of a case_statement shall be static. A discrete_choice
others, if present, shall appear alone and in the last discrete_choice_list.

6/3 The possible values of the selecting_expression shall be covered (see
3.8.1) as follows:

7/4   * If the selecting_expression is a name (including a type_conversion,
        qualified_expression, or function_call) having a static and
        constrained nominal subtype, then each non-others discrete_choice
        shall cover only values in that subtype that satisfy its predicates
        (see 3.2.4), and each value of that subtype that satisfies its
        predicates shall be covered by some discrete_choice (either explicitly
        or by others).

8/3   * If the type of the selecting_expression is root_integer,
        universal_integer, or a descendant of a formal scalar type, then the
        case_statement shall have an others discrete_choice.

9/3   * Otherwise, each value of the base range of the type of the
        selecting_expression shall be covered (either explicitly or by others).

10  Two distinct discrete_choices of a case_statement shall not cover the same
value.


                              Dynamic Semantics

11/3 For the execution of a case_statement the selecting_expression is first
evaluated.

12/3 If the value of the selecting_expression is covered by the discrete_-
choice_list of some case_statement_alternative, then the
sequence_of_statements of the _alternative is executed.

13  Otherwise (the value is not covered by any discrete_choice_list, perhaps
due to being outside the base range), Constraint_Error is raised.

        NOTES

14      4  The execution of a case_statement chooses one and only one
        alternative. Qualification of the expression of a case_statement by a
        static subtype can often be used to limit the number of choices that
        need be given explicitly.


                                  Examples

15  Examples of case statements:

16      case Sensor is
           when Elevation         => Record_Elevation(Sensor_Value);
           when Azimuth           => Record_Azimuth  (Sensor_Value);
           when Distance          => Record_Distance (Sensor_Value);
           when others            => null;
        end case;

17      case Today is
           when Mon               => Compute_Initial_Balance;
           when Fri               => Compute_Closing_Balance;
           when Tue .. Thu        => Generate_Report(Today);
           when Sat .. Sun        => null;
        end case;

18      case Bin_Number(Count) is
           when 1          => Update_Bin(1);
           when 2          => Update_Bin(2);
           when 3 | 4      =>
              Empty_Bin(1);
              Empty_Bin(2);
           when others     => raise Error;
        end case;


5.5 Loop Statements *ada-statements-loop*


1   A loop_statement includes a sequence_of_statements that is to be executed
repeatedly, zero or more times.


                                   Syntax

2       loop_statement ::=
           [loop_statement_identifier:]
              [iteration_scheme] loop
                 sequence_of_statements
               end loop [loop_identifier];

3/3     iteration_scheme ::= while condition
           | for loop_parameter_specification
           | for iterator_specification

4       loop_parameter_specification ::=
           defining_identifier in [reverse] discrete_subtype_definition

5       If a loop_statement has a loop_statement_identifier, then the
        identifier shall be repeated after the end loop; otherwise, there
        shall not be an identifier after the end loop.


                              Static Semantics

6   A loop_parameter_specification declares a loop parameter, which is an
object whose subtype is that defined by the discrete_subtype_definition.


                              Dynamic Semantics

7   For the execution of a loop_statement, the sequence_of_statements is
executed repeatedly, zero or more times, until the loop_statement is complete.
The loop_statement is complete when a transfer of control occurs that
transfers control out of the loop, or, in the case of an iteration_scheme, as
specified below.

8   For the execution of a loop_statement with a while iteration_scheme, the
condition is evaluated before each execution of the sequence_of_statements; if
the value of the condition is True, the sequence_of_statements is executed; if
False, the execution of the loop_statement is complete.

9/4 For the execution of a loop_statement with the iteration_scheme being for
loop_parameter_specification, the loop_parameter_specification is first
elaborated. This elaboration creates the loop parameter and elaborates the
discrete_subtype_definition. If the discrete_subtype_definition defines a
subtype with a null range, the execution of the loop_statement is complete.
Otherwise, the sequence_of_statements is executed once for each value of the
discrete subtype defined by the discrete_subtype_definition that satisfies the
predicates of the subtype (or until the loop is left as a consequence of a
transfer of control). Prior to each such iteration, the corresponding value of
the discrete subtype is assigned to the loop parameter. These values are
assigned in increasing order unless the reserved word reverse is present, in
which case the values are assigned in decreasing order.

9.1/3 For details about the execution of a loop_statement with the
iteration_scheme being for iterator_specification, see 5.5.2.

        NOTES

10      5  A loop parameter is a constant; it cannot be updated within the
        sequence_of_statements of the loop (see 3.3).

11      6  An object_declaration should not be given for a loop parameter,
        since the loop parameter is automatically declared by the
        loop_parameter_specification. The scope of a loop parameter extends
        from the loop_parameter_specification to the end of the
        loop_statement, and the visibility rules are such that a loop
        parameter is only visible within the sequence_of_statements of the
        loop.

12      7  The discrete_subtype_definition of a for loop is elaborated just
        once. Use of the reserved word reverse does not alter the discrete
        subtype defined, so that the following iteration_schemes are not
        equivalent; the first has a null range.

13          for J in reverse 1 .. 0
            for J in 0 .. 1


                                  Examples

14  Example of a loop statement without an iteration scheme:

15      loop
           Get(Current_Character);
           exit when Current_Character = '*';
        end loop;

16  Example of a loop statement with a while iteration scheme:

17      while Bid(N).Price < Cut_Off.Price loop
           Record_Bid(Bid(N).Price);
           N := N + 1;
        end loop;

18  Example of a loop statement with a for iteration scheme:

19      for J in Buffer'Range loop     --  works even with a null range
           if Buffer(J) /= Space then
              Put(Buffer(J));
           end if;
        end loop;

20  Example of a loop statement with a name:

21      Summation:
           while Next /= Head loop       -- see 3.10.1
              Sum  := Sum + Next.Value;
              Next := Next.Succ;
           end loop Summation;


5.5.1 User-Defined Iterator Types *ada-statements-user-defined*



                              Static Semantics

1/3 The following language-defined generic library package exists:

2/3     generic
           type Cursor;
           with function Has_Element (Position : Cursor) return Boolean;
        package Ada.Iterator_Interfaces is
           pragma Pure (Iterator_Interfaces);

3/3        type Forward_Iterator is limited interface;
           function First
         (Object : Forward_Iterator) return Cursor is abstract;
           function Next (Object : Forward_Iterator; Position : Cursor)
              return Cursor is abstract;

4/3        type Reversible_Iterator is limited interface and Forward_Iterator;
           function Last
         (Object : Reversible_Iterator) return Cursor is abstract;
           function Previous (Object : Reversible_Iterator; Position : Cursor)
              return Cursor is abstract;

5/3     end Ada.Iterator_Interfaces;

6/3 An iterator type is a type descended from the Forward_Iterator interface
from some instance of Ada.Iterator_Interfaces. A reversible iterator type is a
type descended from the Reversible_Iterator interface from some instance of
Ada.Iterator_Interfaces. An iterator object is an object of an iterator type.
A reversible iterator object is an object of a reversible iterator type. The
formal subtype Cursor from the associated instance of Ada.Iterator_Interfaces
is the iteration cursor subtype for the iterator type.

7/3 The following type-related operational aspects may be specified for an
indexable container type T (see 4.1.6):

8/3 Default_Iterator
                This aspect is specified by a name that denotes exactly one
                function declared immediately within the same declaration list
                in which T is declared, whose first parameter is of type T or
                T'Class or an access parameter whose designated type is type T
                or T'Class, whose other parameters, if any, have default
                expressions, and whose result type is an iterator type. This
                function is the default iterator function for T. Its result
                subtype is the default iterator subtype for T. The iteration
                cursor subtype for the default iterator subtype is the default
                cursor subtype for T.

9/3 Iterator_Element
                This aspect is specified by a name that denotes a subtype.
                This is the default element subtype for T.

10/3 These aspects are inherited by descendants of type T (including T'Class).

11/3 An iterable container type is an indexable container type with specified
Default_Iterator and Iterator_Element aspects. A reversible iterable container
type is an iterable container type with the default iterator type being a
reversible iterator type. An iterable container object is an object of an
iterable container type. A reversible iterable container object is an object
of a reversible iterable container type.

11.1/4 The Default_Iterator and Iterator_Element aspects are nonoverridable
(see 13.1.1).


                               Legality Rules

12/3 The Constant_Indexing aspect (if any) of an iterable container type T
shall denote exactly one function with the following properties:

13/3   * the result type of the function is covered by the default element
        type of T or is a reference type (see 4.1.5) with an access
        discriminant designating a type covered by the default element type of
        T;

14/3   * the type of the second parameter of the function covers the default
        cursor type for T;

15/3   * if there are more than two parameters, the additional parameters all
        have default expressions.

16/3 This function (if any) is the default constant indexing function for T.

17/3 The Variable_Indexing aspect (if any) of an iterable container type T
shall denote exactly one function with the following properties:

18/3   * the result type of the function is a reference type (see 4.1.5) with
        an access discriminant designating a type covered by the default
        element type of T;

19/3   * the type of the second parameter of the function covers the default
        cursor type for T;

20/3   * if there are more than two parameters, the additional parameters all
        have default expressions.

21/3 This function (if any) is the default variable indexing function for T.


5.5.2 Generalized Loop Iteration *ada-statements-generalized*


1/3 Generalized forms of loop iteration are provided by an
iterator_specification.


                                   Syntax

2/3     iterator_specification ::=
            defining_identifier in [reverse] iterator_name
          | defining_identifier [: subtype_indication
        ] of [reverse] iterable_name


                            Name Resolution Rules

3/3 For the first form of iterator_specification, called a generalized
iterator, the expected type for the iterator_name is any iterator type. For
the second form of iterator_specification, the expected type for the
iterable_name is any array or iterable container type. If the iterable_name denotes an
array object, the iterator_specification is called an array component
iterator; otherwise it is called a container element iterator.


                               Legality Rules

4/3 If the reserved word reverse appears, the iterator_specification is a
reverse iterator; otherwise it is a forward iterator. In a reverse generalized
iterator, the iterator_name shall be of a reversible iterator type. In a
reverse container element iterator, the default iterator type for the type of
the iterable_name shall be a reversible iterator type.

5/4 The subtype defined by the subtype_indication, if any, of an array
component iterator shall statically match the component subtype of the type of
the iterable_name. The subtype defined by the subtype_indication, if any, of a
container element iterator shall statically match the default element subtype
for the type of the iterable_name.

6/3 In a container element iterator whose iterable_name has type T, if the
iterable_name denotes a constant or the Variable_Indexing aspect is not
specified for T, then the Constant_Indexing aspect shall be specified for T.

6.1/4 The iterator_name or iterable_name of an iterator_specification shall
not denote a subcomponent that depends on discriminants of an object whose
nominal subtype is unconstrained, unless the object is known to be constrained.

6.2/4 A container element iterator is illegal if the call of the default
iterator function that creates the loop iterator (see below) is illegal.

6.3/4 A generalized iterator is illegal if the iteration cursor subtype of the
iterator_name is a limited type at the point of the generalized iterator. A
container element iterator is illegal if the default cursor subtype of the
type of the iterable_name is a limited type at the point of the container
element iterator.


                              Static Semantics

7/3 An iterator_specification declares a loop parameter. In a generalized
iterator, the nominal subtype of the loop parameter is the iteration cursor
subtype. In an array component iterator or a container element iterator, if a
subtype_indication is present, it determines the nominal subtype of the loop
parameter. In an array component iterator, if a subtype_indication is not
present, the nominal subtype of the loop parameter is the component subtype of
the type of the iterable_name. In a container element iterator, if a
subtype_indication is not present, the nominal subtype of the loop parameter
is the default element subtype for the type of the iterable_name.

8/3 In a generalized iterator, the loop parameter is a constant. In an array
component iterator, the loop parameter is a constant if the iterable_name
denotes a constant; otherwise it denotes a variable. In a container element
iterator, the loop parameter is a constant if the iterable_name denotes a
constant, or if the Variable_Indexing aspect is not specified for the type of
the iterable_name; otherwise it is a variable.


                              Dynamic Semantics

9/3 For the execution of a loop_statement with an iterator_specification, the
iterator_specification is first elaborated. This elaboration elaborates the
subtype_indication, if any.

10/3 For a generalized iterator, the loop parameter is created, the
iterator_name is evaluated, and the denoted iterator object becomes the loop iterator.
In a forward generalized iterator, the operation First of the iterator type is
called on the loop iterator, to produce the initial value for the loop
parameter. If the result of calling Has_Element on the initial value is False,
then the execution of the loop_statement is complete. Otherwise, the
sequence_of_statements is executed and then the Next operation of the iterator
type is called with the loop iterator and the current value of the loop
parameter to produce the next value to be assigned to the loop parameter. This
repeats until the result of calling Has_Element on the loop parameter is
False, or the loop is left as a consequence of a transfer of control. For a
reverse generalized iterator, the operations Last and Previous are called
rather than First and Next.

11/3 For an array component iterator, the iterable_name is evaluated and the
denoted array object becomes the array for the loop. If the array for the loop
is a null array, then the execution of the loop_statement is complete.
Otherwise, the sequence_of_statements is executed with the loop parameter
denoting each component of the array for the loop, using a canonical order of
components, which is last dimension varying fastest (unless the array has
convention Fortran, in which case it is first dimension varying fastest). For
a forward array component iterator, the iteration starts with the component
whose index values are each the first in their index range, and continues in
the canonical order. For a reverse array component iterator, the iteration
starts with the component whose index values are each the last in their index
range, and continues in the reverse of the canonical order. The loop iteration
proceeds until the sequence_of_statements has been executed for each component
of the array for the loop, or until the loop is left as a consequence of a
transfer of control.

12/3 For a container element iterator, the iterable_name is evaluated and the
denoted iterable container object becomes the iterable container object for
the loop. The default iterator function for the type of the iterable container
object for the loop is called on the iterable container object and the result
is the loop iterator. An object of the default cursor subtype is created (the
loop cursor).

13/3 For a forward container element iterator, the operation First of the
iterator type is called on the loop iterator, to produce the initial value for
the loop cursor. If the result of calling Has_Element on the initial value is
False, then the execution of the loop_statement is complete. Otherwise, the
sequence_of_statements is executed with the loop parameter denoting an
indexing (see 4.1.6) into the iterable container object for the loop, with the
only parameter to the indexing being the current value of the loop cursor;
then the Next operation of the iterator type is called with the loop iterator
and the loop cursor to produce the next value to be assigned to the loop
cursor. This repeats until the result of calling Has_Element on the loop
cursor is False, or until the loop is left as a consequence of a transfer of
control. For a reverse container element iterator, the operations Last and
Previous are called rather than First and Next. If the loop parameter is a
constant (see above), then the indexing uses the default constant indexing
function for the type of the iterable container object for the loop; otherwise
it uses the default variable indexing function.

14/4 Any exception propagated by the execution of a generalized iterator or
container element iterator is propagated by the immediately enclosing loop
statement.


                                  Examples

15/3    -- Array component iterator example:
        for Element of Board loop  -- See 3.6.1.
           Element := Element * 2.0; -- Double each element of Board, a two-dimensional array.
        end loop;

16/3 For examples of use of generalized iterators, see A.18.32 and the
corresponding container packages in A.18.2 and A.18.3.


5.6 Block Statements *ada-statements-block*


1   A block_statement encloses a handled_sequence_of_statements optionally
preceded by a declarative_part.


                                   Syntax

2       block_statement ::=
           [block_statement_identifier:]
               [declare
                    declarative_part]
                begin
                    handled_sequence_of_statements
                end [block_identifier];

3       If a block_statement has a block_statement_identifier, then the
        identifier shall be repeated after the end; otherwise, there shall not
        be an identifier after the end.


                              Static Semantics

4   A block_statement that has no explicit declarative_part has an implicit
empty declarative_part.


                              Dynamic Semantics

5   The execution of a block_statement consists of the elaboration of its
declarative_part followed by the execution of its
handled_sequence_of_statements.


                                  Examples

6   Example of a block statement with a local variable:

7       Swap:
           declare
              Temp : Integer;
           begin
              Temp := V; V := U; U := Temp;
           end Swap;


5.7 Exit Statements *ada-statements-exit*


1   An exit_statement is used to complete the execution of an enclosing
loop_statement; the completion is conditional if the exit_statement includes a
condition.


                                   Syntax

2       exit_statement ::=
           exit [loop_name] [when condition];


                            Name Resolution Rules

3   The loop_name, if any, in an exit_statement shall resolve to denote a
loop_statement.


                               Legality Rules

4   Each exit_statement applies to a loop_statement; this is the
loop_statement being exited. An exit_statement with a name is only allowed
within the loop_statement denoted by the name, and applies to that loop_-
statement. An exit_statement without a name is only allowed within a loop_-
statement, and applies to the innermost enclosing one. An exit_statement that
applies to a given loop_statement shall not appear within a body or accept_-
statement, if this construct is itself enclosed by the given loop_statement.


                              Dynamic Semantics

5   For the execution of an exit_statement, the condition, if present, is
first evaluated. If the value of the condition is True, or if there is no
condition, a transfer of control is done to complete the loop_statement. If
the value of the condition is False, no transfer of control takes place.

        NOTES

6       8  Several nested loops can be exited by an exit_statement that names
        the outer loop.


                                  Examples

7   Examples of loops with exit statements:

8       for N in 1 .. Max_Num_Items loop
           Get_New_Item(New_Item);
           Merge_Item(New_Item, Storage_File);
           exit when New_Item = Terminal_Item;
        end loop;

9       Main_Cycle:
           loop
              --  initial statements
              exit Main_Cycle when Found;
              --  final statements
           end loop Main_Cycle;


5.8 Goto Statements *ada-statements-goto*


1   A goto_statement specifies an explicit transfer of control from this
statement to a target statement with a given label.


                                   Syntax

2       goto_statement ::= goto label_name;


                            Name Resolution Rules

3   The label_name shall resolve to denote a label; the statement with that
label is the target statement.


                               Legality Rules

4   The innermost sequence_of_statements that encloses the target statement
shall also enclose the goto_statement. Furthermore, if a goto_statement is
enclosed by an accept_statement or a body, then the target statement shall not
be outside this enclosing construct.


                              Dynamic Semantics

5   The execution of a goto_statement transfers control to the target
statement, completing the execution of any compound_statement that encloses
the goto_statement but does not enclose the target.

        NOTES

6       9  The above rules allow transfer of control to a statement of an
        enclosing sequence_of_statements but not the reverse. Similarly, they
        prohibit transfers of control such as between alternatives of a
        case_statement, if_statement, or select_statement; between
        exception_handlers; or from an exception_handler of a
        handled_sequence_of_statements back to its sequence_of_statements.


                                  Examples

7   Example of a loop containing a goto statement:

8       <<Sort>>
        for I in 1 .. N-1 loop
           if A(I) > A(I+1) then
              Exchange(A(I), A(I+1));
              goto Sort;
           end if;
        end loop;

